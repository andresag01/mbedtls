/* BEGIN_HEADER */
#include "mbedtls/bignum.h"
#include "mbedtls/timing.h"
#include "mbedtls/ctr_drbg.h"
#include "mbedtls/rsa.h"
#include "mbedtls/md.h"
#include "mbedtls/error.h"

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sched.h>

int timeconst_mpi_shift( int samples, int mpi_size,
                         mbedtls_ctr_drbg_context *ctr_drbg,
                         int (*fut)(mbedtls_mpi *, size_t),
                         const char *fut_str, unsigned long long time_adj );

int timeconst_mpi_mpi( int samples, int mpi_size,
                       mbedtls_ctr_drbg_context *ctr_drbg,
                       int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                  const mbedtls_mpi *),
                       const char *fut_str, unsigned long long time_adj );

int timeconst_mpi_int( int samples, int mpi_size,
                       mbedtls_ctr_drbg_context *ctr_drbg,
                       int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                  mbedtls_mpi_sint),
                       const char *fut_str, unsigned long long time_adj );

int timeconst_mpi_div_int( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, mbedtls_mpi *,
                                      const mbedtls_mpi *,
                                      mbedtls_mpi_sint),
                           const char *fut_str, unsigned long long time_adj );

int timeconst_mpi_mod_int( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi_uint *, const mbedtls_mpi *,
                                      mbedtls_mpi_sint),
                           const char *fut_str, unsigned long long time_adj );

int timeconst_mpi_div_mpi( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, mbedtls_mpi *,
                                      const mbedtls_mpi *, const mbedtls_mpi *),
                           const char *fut_str, unsigned long long time_adj );

int timeconst_mpi_mul_int( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                      mbedtls_mpi_uint),
                           const char *fut_str, unsigned long long time_adj );

int timeconst_mpi_exp_mod( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                      const mbedtls_mpi *, const mbedtls_mpi *,
                                      mbedtls_mpi *),
                           const char *fut_str, unsigned long long time_adj );

int timeconst_rsa_rsaes_pkcs1_v15( int samples, int keysize,
                                   mbedtls_ctr_drbg_context *ctr_drbg,
                                   unsigned long long time_adj );

int timeconst_rsa_rsaes_oaep( int samples, int keysize,
                              mbedtls_ctr_drbg_context *ctr_drbg,
                              unsigned long long time_adj );

int timeconst_rsa_sign( int samples, int keysize,
                        mbedtls_ctr_drbg_context *ctr_drbg,
                        unsigned long long time_adj, int digest_len, int padding,
                        int (*fut)(mbedtls_rsa_context *,
                                   int (*)(void *, unsigned char *, size_t),
                                   void *, int, mbedtls_md_type_t, unsigned int,
                                   const unsigned char *, unsigned char *),
                        const char *fut_str );

unsigned long long timeconst_calibrate_clock( unsigned long long (*f_clock)(void) );

int timeconst_increase_priority();

int timeconst_random( void *p_rng, unsigned char *output, size_t output_len );

#define TIMECONST_STATS(ctx,fut_str)                                        \
{                                                                           \
    unsigned long long max, min;                                            \
    double mean, variance, std_dev, median;                                 \
    mean = mbedtls_timeconst_get_mean( ctx );                               \
    median = mbedtls_timeconst_get_median( ctx );                           \
    variance = mbedtls_timeconst_get_variance( ctx );                       \
    std_dev = sqrt( variance );                                             \
    min = mbedtls_timeconst_min_sample( ctx );                              \
    max = mbedtls_timeconst_max_sample( ctx );                              \
                                                                            \
    mbedtls_printf( "%-40s%30.2f%30.2f%30.2f%30llu%30llu\n",                \
                    fut_str, median, mean, std_dev, min, max );             \
                                                                            \
    if( ( ret = mbedtls_timeconst_write_file( ctx, fut_str ) ) != 0 )       \
        goto exit;                                                          \
}

#define TIMECONST_TIMEDIFF(start,end,adj)                                   \
    (end - start < adj) ? 0 : end - start - adj

#define TIMECONST_CHECK(code, exp_ret)                                        \
{                                                                             \
    ret = code;                                                               \
    if( ret != exp_ret )                                                      \
    {                                                                         \
        mbedtls_strerror( ret, buf, sizeof( buf ) );                          \
        mbedtls_printf( "Err: %04X, Msg: %s, Code: %s\n", -ret, buf, #code ); \
        goto exit;                                                            \
    }                                                                         \
}

/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_BIGNUM_C:MBEDTLS_TIMING_C:MBEDTLS_CTR_DRBG_C:MBEDTLS_RSA_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE */
void timeconst_rsa( int samples )
{
    mbedtls_ctr_drbg_context ctr_drbg;
    unsigned long long time_adj;

    mbedtls_ctr_drbg_init( &ctr_drbg );
    time_adj = timeconst_calibrate_clock( mbedtls_timing_threadclock );
    TEST_ASSERT( timeconst_increase_priority() == 0 );

    TEST_ASSERT( mbedtls_ctr_drbg_seed( &ctr_drbg, myrand, NULL, NULL, 0 ) == 0 );

    mbedtls_printf( "\n%-40s%30s%30s%30s%30s%30s\n", "Function under test",
                    "Median", "Mean", "Std dev", "Min", "Max" );

    TEST_ASSERT( timeconst_rsa_rsaes_pkcs1_v15( samples, 2048,
                 &ctr_drbg, time_adj ) == 0 );
    TEST_ASSERT( timeconst_rsa_rsaes_pkcs1_v15( samples, 4096,
                 &ctr_drbg, time_adj ) == 0 );

    TEST_ASSERT( timeconst_rsa_rsaes_oaep( samples, 2048,
                 &ctr_drbg, time_adj ) == 0 );
    TEST_ASSERT( timeconst_rsa_rsaes_oaep( samples, 4096,
                 &ctr_drbg, time_adj ) == 0 );

    TEST_ASSERT( timeconst_rsa_sign( samples, 2048, &ctr_drbg, time_adj, 256 - 3 - 8,
                 MBEDTLS_RSA_PKCS_V15, mbedtls_rsa_rsassa_pkcs1_v15_sign,
                 "mbedtls_rsa_rsassa_pkcs1_v15_sign" ) == 0 );
    TEST_ASSERT( timeconst_rsa_sign( samples, 4096, &ctr_drbg, time_adj, 512 - 3 - 8,
                 MBEDTLS_RSA_PKCS_V15, mbedtls_rsa_rsassa_pkcs1_v15_sign,
                 "mbedtls_rsa_rsassa_pkcs1_v15_sign" ) == 0 );

    TEST_ASSERT( timeconst_rsa_sign( samples, 2048, &ctr_drbg, time_adj, 256,
                 MBEDTLS_RSA_PKCS_V21, mbedtls_rsa_rsassa_pss_sign,
                 "mbedtls_rsa_rsassa_pss_sign" ) == 0 );
    TEST_ASSERT( timeconst_rsa_sign( samples, 2048, &ctr_drbg, time_adj, 512,
                 MBEDTLS_RSA_PKCS_V21, mbedtls_rsa_rsassa_pss_sign,
                 "mbedtls_rsa_rsassa_pss_sign" ) == 0 );

exit:
    mbedtls_ctr_drbg_free( &ctr_drbg );
}

int my_non_rand( void *ctx, unsigned char *buf, size_t buf_len )
{
    (void) ctx;

    memset( buf, 0xBE, buf_len );
    return( 0 );
}

int timeconst_rsa_sign( int samples, int keysize,
                        mbedtls_ctr_drbg_context *ctr_drbg,
                        unsigned long long time_adj, int digest_len, int padding,
                        int (*fut)(mbedtls_rsa_context *,
                                   int (*)(void *, unsigned char *, size_t),
                                   void *, int, mbedtls_md_type_t, unsigned int,
                                   const unsigned char *, unsigned char *),
                        const char *fut_str )
{
    size_t i;
    int ret;
    unsigned long long start_time, end_time;
    char buf[1024];
    unsigned char input[1024], output[1024];
    mbedtls_timeconst_context timeconst;
    mbedtls_rsa_context rsa;

    mbedtls_timeconst_init( &timeconst );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < (size_t)samples; i++ )
    {
        mbedtls_rsa_init( &rsa, padding, MBEDTLS_MD_SHA256 );

        TIMECONST_CHECK( mbedtls_rsa_gen_key( &rsa, timeconst_random, ctr_drbg,
                         (unsigned int)keysize, 65537 ), 0 );
        TIMECONST_CHECK( timeconst_random( ctr_drbg, input, (size_t)digest_len ),
                         0 );

        start_time = mbedtls_timing_threadclock();
        ret = fut( &rsa, my_non_rand, NULL, input[0] & 0x01, MBEDTLS_MD_NONE,
                   (unsigned int)digest_len, input, output );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
        {
            mbedtls_printf( "i:%zu, ret:%04X\n", i, -ret );
            goto exit;
        }
        TIMECONST_CHECK( mbedtls_timeconst_add_sample( &timeconst,
                        TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) ), 0 );

        mbedtls_rsa_free( &rsa );
    }

    mbedtls_snprintf( buf, sizeof( buf ), "%s_%d", fut_str, keysize );
    TIMECONST_STATS( &timeconst, buf );

    goto free;

exit:
    mbedtls_rsa_free( &rsa );

free:
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_rsa_rsaes_oaep( int samples, int keysize,
                              mbedtls_ctr_drbg_context *ctr_drbg,
                              unsigned long long time_adj )
{
    size_t i;
    int ret;
    unsigned char input[1024], output[1024];
    unsigned long long start_time, end_time;
    size_t olen;
    size_t keysize_bytes = keysize >> 3;
    char buf[1024];
    mbedtls_rsa_context rsa;
    mbedtls_timeconst_context timeconst_enc, timeconst_dec;

    mbedtls_timeconst_init( &timeconst_dec );
    mbedtls_timeconst_init( &timeconst_enc );

    memset( input, 0, sizeof( input ) );
    mbedtls_timeconst_setup( &timeconst_dec, (size_t)samples );
    mbedtls_timeconst_setup( &timeconst_enc, (size_t)samples );

    for( i = 0; i < (size_t)samples; i++ )
    {
        mbedtls_rsa_init( &rsa, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256 );

        TIMECONST_CHECK( mbedtls_rsa_gen_key( &rsa, timeconst_random, ctr_drbg,
                         (unsigned int)keysize, 65537 ), 0 );
        TIMECONST_CHECK( timeconst_random( ctr_drbg, input, keysize_bytes - 11 ), 0 );

        start_time = mbedtls_timing_threadclock();
        ret = mbedtls_rsa_rsaes_oaep_encrypt( &rsa, my_non_rand, NULL,
              input[0] & 0x01, NULL, 0, keysize_bytes - 66, input, output );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;
        TIMECONST_CHECK( mbedtls_timeconst_add_sample( &timeconst_enc,
                        TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) ), 0 );

        start_time = mbedtls_timing_threadclock();
        ret = mbedtls_rsa_rsaes_oaep_decrypt( &rsa, my_non_rand, NULL,
              ~input[0] & 0x01, NULL, 0, &olen, output, input, sizeof( input ) );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;
        TIMECONST_CHECK( mbedtls_timeconst_add_sample( &timeconst_dec,
                         TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) ), 0 );

        mbedtls_rsa_free( &rsa );
    }

    mbedtls_snprintf( buf, sizeof( buf ), "mbedtls_rsaes_oaep_encrypt_%d",
                      keysize );
    TIMECONST_STATS( &timeconst_enc, buf );
    mbedtls_snprintf( buf, sizeof( buf ), "mbedtls_rsaes_oaep_decrypt_%d",
                      keysize );
    TIMECONST_STATS( &timeconst_dec, buf );

    goto free;

exit:
    mbedtls_rsa_free( &rsa );

free:
    mbedtls_timeconst_free( &timeconst_dec );
    mbedtls_timeconst_free( &timeconst_enc );

    return( ret );
}

int timeconst_rsa_rsaes_pkcs1_v15( int samples, int keysize,
                                   mbedtls_ctr_drbg_context *ctr_drbg,
                                   unsigned long long time_adj )
{
    size_t i;
    int ret;
    unsigned char input[1024], output[1024];
    unsigned long long start_time, end_time;
    size_t olen;
    size_t keysize_bytes = keysize >> 3;
    char buf[1024];
    mbedtls_rsa_context rsa;
    mbedtls_timeconst_context timeconst_enc, timeconst_dec;

    mbedtls_timeconst_init( &timeconst_dec );
    mbedtls_timeconst_init( &timeconst_enc );

    memset( input, 0, sizeof( input ) );
    mbedtls_timeconst_setup( &timeconst_dec, (size_t)samples );
    mbedtls_timeconst_setup( &timeconst_enc, (size_t)samples );

    for( i = 0; i < (size_t)samples; i++ )
    {
        mbedtls_rsa_init( &rsa, MBEDTLS_RSA_PKCS_V15, MBEDTLS_MD_SHA256 );

        TIMECONST_CHECK( mbedtls_rsa_gen_key( &rsa, timeconst_random, ctr_drbg,
                         (unsigned int)keysize, 65537 ), 0 );
        TIMECONST_CHECK( timeconst_random( ctr_drbg, input, keysize_bytes - 11 ), 0 );

        start_time = mbedtls_timing_threadclock();
        ret = mbedtls_rsa_rsaes_pkcs1_v15_encrypt( &rsa, my_non_rand, NULL,
              input[0] & 0x01, keysize_bytes - 11, input, output );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;
        TIMECONST_CHECK( mbedtls_timeconst_add_sample( &timeconst_enc,
                        TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) ), 0 );

        start_time = mbedtls_timing_threadclock();
        ret = mbedtls_rsa_rsaes_pkcs1_v15_decrypt( &rsa, my_non_rand, NULL,
              ~input[0] & 0x01, &olen, output, input, sizeof( input ) );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;
        TIMECONST_CHECK( mbedtls_timeconst_add_sample( &timeconst_dec,
                         TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) ), 0 );

        mbedtls_rsa_free( &rsa );
    }

    mbedtls_snprintf( buf, sizeof( buf ), "mbedtls_rsaes_pkcs1_v15_encrypt_%d",
                      keysize );
    TIMECONST_STATS( &timeconst_enc, buf );
    mbedtls_snprintf( buf, sizeof( buf ), "mbedtls_rsaes_pkcs1_v15_decrypt_%d",
                      keysize );
    TIMECONST_STATS( &timeconst_dec, buf );

    goto free;

exit:
    mbedtls_rsa_free( &rsa );

free:
    mbedtls_timeconst_free( &timeconst_dec );
    mbedtls_timeconst_free( &timeconst_enc );

    return( ret );
}
/* END_CASE */

/* BEGIN_CASE */
void timeconst_mpi( int samples, int mpi_size )
{
    mbedtls_ctr_drbg_context ctr_drbg;
    unsigned long long time_adj;

    mbedtls_ctr_drbg_init( &ctr_drbg );
    time_adj = timeconst_calibrate_clock( mbedtls_timing_threadclock );
    TEST_ASSERT( timeconst_increase_priority() == 0 );

    TEST_ASSERT( mbedtls_ctr_drbg_seed( &ctr_drbg, myrand, NULL, NULL, 0 ) == 0 );

    mbedtls_printf( "\n%-40s%30s%30s%30s%30s%30s\n", "Function under test",
                    "Median", "Mean", "Std dev", "Min", "Max" );

    TEST_ASSERT( timeconst_mpi_shift( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_shift_l, "mbedtls_mpi_shift_l", time_adj ) == 0 );
    TEST_ASSERT( timeconst_mpi_shift( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_shift_r, "mbedtls_mpi_shift_r", time_adj ) == 0 );

    TEST_ASSERT( timeconst_mpi_mpi( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_add_abs, "mbedtls_mpi_add_abs", time_adj ) == 0 );
    TEST_ASSERT( timeconst_mpi_mpi( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_sub_abs, "mbedtls_mpi_sub_abs", time_adj ) == 0 );
    TEST_ASSERT( timeconst_mpi_mpi( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_add_mpi, "mbedtls_mpi_add_mpi", time_adj ) == 0 );
    TEST_ASSERT( timeconst_mpi_mpi( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_sub_mpi, "mbedtls_mpi_sub_mpi", time_adj ) == 0 );
    TEST_ASSERT( timeconst_mpi_mpi( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_mul_mpi, "mbedtls_mpi_mul_mpi", time_adj ) == 0 );
    TEST_ASSERT( timeconst_mpi_mpi( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_mod_mpi, "mbedtls_mpi_mod_mpi", time_adj ) == 0 );

    TEST_ASSERT( timeconst_mpi_int( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_add_int, "mbedtls_mpi_add_int", time_adj ) == 0 );
    TEST_ASSERT( timeconst_mpi_int( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_sub_int, "mbedtls_mpi_sub_int", time_adj ) == 0 );

    TEST_ASSERT( timeconst_mpi_div_int( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_div_int, "mbedtls_mpi_div_int", time_adj ) == 0 );

    TEST_ASSERT( timeconst_mpi_mod_int( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_mod_int, "mbedtls_mpi_mod_int", time_adj ) == 0 );

    TEST_ASSERT( timeconst_mpi_div_mpi( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_div_mpi, "mbedtls_mpi_div_mpi", time_adj ) == 0 );

    TEST_ASSERT( timeconst_mpi_mul_int( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_mul_int, "mbedtls_mpi_mul_int", time_adj ) == 0 );

    TEST_ASSERT( timeconst_mpi_exp_mod( samples, mpi_size, &ctr_drbg,
                 mbedtls_mpi_exp_mod, "mbedtls_mpi_exp_mod", time_adj ) == 0 );

exit:
    mbedtls_ctr_drbg_free( &ctr_drbg );
}

int timeconst_increase_priority()
{
    struct sched_param p;
    p.sched_priority = sched_get_priority_max( SCHED_FIFO );
    return sched_setscheduler( 0, SCHED_FIFO, &p );
}

unsigned long long timeconst_calibrate_clock( unsigned long long (*f_clock)(void) )
{
    unsigned long long samples;
    unsigned long long start_time;
    unsigned long long end_time;
    unsigned long long acc = 0;

    for( samples = 0; samples < 1000; samples++ )
    {
        start_time = f_clock();
        end_time = f_clock();
        acc += end_time - start_time;
    }

    return( acc / samples );
}

int timeconst_random( void *p_rng, unsigned char *output, size_t output_len )
{
#if 0
    size_t i;
    (void) p_rng;

    for( i = 0; i < output_len; i++ )
        output[i] = 1;

    return( 0 );
#else
    return( mbedtls_ctr_drbg_random( p_rng, output, output_len ) );
#endif
}

int timeconst_mpi_exp_mod( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                      const mbedtls_mpi *, const mbedtls_mpi *,
                                      mbedtls_mpi *),
                           const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi X, A, E, N, _RR;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &A );
    mbedtls_mpi_init( &X );
    mbedtls_mpi_init( &E );
    mbedtls_mpi_init( &N );
    mbedtls_mpi_init( &_RR );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &N, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;
        else if( mbedtls_mpi_cmp_int( &N, 0 ) == 0 )
        {
            i--;
            continue;
        }
        /* Make sure that N is always odd to avoid failure */
        N.p[0] |= 1;

        ret = mbedtls_mpi_fill_random( &A, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = mbedtls_mpi_fill_random( &E, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        start_time = mbedtls_timing_threadclock();
        ret = fut( &X, &A, &E, &N, &_RR );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &A );
    mbedtls_mpi_free( &X );
    mbedtls_mpi_free( &E );
    mbedtls_mpi_free( &N );
    mbedtls_mpi_free( &_RR );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_mpi_mul_int( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                      mbedtls_mpi_uint),
                           const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi A, X;
    mbedtls_mpi_uint b;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &A );
    mbedtls_mpi_init( &X );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &A, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = timeconst_random( ctr_drbg, (unsigned char *)&b,
                                       sizeof( mbedtls_mpi_uint ) );
        if( ret != 0 )
            goto exit;

        start_time = mbedtls_timing_threadclock();
        ret = fut( &X, &A, b );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &A );
    mbedtls_mpi_free( &X );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_mpi_div_mpi( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, mbedtls_mpi *,
                                      const mbedtls_mpi *, const mbedtls_mpi *),
                           const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi Q, R, A, B;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &Q );
    mbedtls_mpi_init( &R );
    mbedtls_mpi_init( &A );
    mbedtls_mpi_init( &B );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &A, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = mbedtls_mpi_fill_random( &B, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        if( mbedtls_mpi_cmp_int( &B, 0 ) == 0 )
        {
            i--;
            continue;
        }

        start_time = mbedtls_timing_threadclock();
        ret = fut( &Q, &R, &A, &B );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &Q );
    mbedtls_mpi_free( &R );
    mbedtls_mpi_free( &A );
    mbedtls_mpi_free( &B );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_mpi_mod_int( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi_uint *, const mbedtls_mpi *,
                                      mbedtls_mpi_sint),
                           const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi A;
    mbedtls_mpi_sint b;
    mbedtls_mpi_uint r;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &A );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &A, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = timeconst_random( ctr_drbg, (unsigned char *)&b,
                                       sizeof( mbedtls_mpi_sint ) );
        if( ret != 0 )
            goto exit;

        if( b <= 0 )
        {
            i--;
            continue;
        }

        start_time = mbedtls_timing_threadclock();
        ret = fut( &r, &A, b );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &A );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_mpi_div_int( int samples, int mpi_size,
                           mbedtls_ctr_drbg_context *ctr_drbg,
                           int (*fut)(mbedtls_mpi *, mbedtls_mpi *,
                                      const mbedtls_mpi *, mbedtls_mpi_sint),
                           const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi Q, R, A;
    mbedtls_mpi_sint b;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &Q );
    mbedtls_mpi_init( &R );
    mbedtls_mpi_init( &A );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &A, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = timeconst_random( ctr_drbg, (unsigned char *)&b,
                                       sizeof( mbedtls_mpi_sint ) );
        if( ret != 0 )
            goto exit;

        if( b == 0 )
        {
            i--;
            continue;
        }

        start_time = mbedtls_timing_threadclock();
        ret = fut( &Q, &R, &A, b );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &Q );
    mbedtls_mpi_free( &R );
    mbedtls_mpi_free( &A );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_mpi_int( int samples, int mpi_size,
                       mbedtls_ctr_drbg_context *ctr_drbg,
                       int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                  mbedtls_mpi_sint),
                       const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi res, op1;
    mbedtls_mpi_sint op2;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &res );
    mbedtls_mpi_init( &op1 );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &op1, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = timeconst_random( ctr_drbg, (unsigned char *)&op2,
                                       sizeof( mbedtls_mpi_sint ) );
        if( ret != 0 )
            goto exit;

        start_time = mbedtls_timing_threadclock();
        ret = fut( &res, &op1, op2 );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &res );
    mbedtls_mpi_free( &op1 );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_mpi_mpi( int samples, int mpi_size,
                       mbedtls_ctr_drbg_context *ctr_drbg,
                       int (*fut)(mbedtls_mpi *, const mbedtls_mpi *,
                                  const mbedtls_mpi *),
                       const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi res, op1, op2;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &res );
    mbedtls_mpi_init( &op1 );
    mbedtls_mpi_init( &op2 );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &op1, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = mbedtls_mpi_fill_random( &op2, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        if( mbedtls_mpi_cmp_int( &op1, 0 ) == 0 ||
            mbedtls_mpi_cmp_int( &op2, 0 ) == 0 )
        {
            i--;
            continue;
        }
        else if( mbedtls_mpi_cmp_abs( &op1, &op2 )  < 0 )
        {
            start_time = mbedtls_timing_threadclock();
            ret = fut( &res, &op2, &op1 );
            end_time = mbedtls_timing_threadclock();
        }
        else
        {
            start_time = mbedtls_timing_threadclock();
            ret = fut( &res, &op1, &op2 );
            end_time = mbedtls_timing_threadclock();
        }
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &res );
    mbedtls_mpi_free( &op1 );
    mbedtls_mpi_free( &op2 );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}

int timeconst_mpi_shift( int samples, int mpi_size,
                         mbedtls_ctr_drbg_context *ctr_drbg,
                         int (*fut)(mbedtls_mpi *, size_t),
                         const char *fut_str, unsigned long long time_adj )
{
    int i;
    int ret;
    mbedtls_mpi X;
    size_t shift_cnt;
    unsigned long long start_time, end_time;
    mbedtls_timeconst_context timeconst;

    mbedtls_timeconst_init( &timeconst );
    mbedtls_mpi_init( &X );

    mbedtls_timeconst_setup( &timeconst, (size_t)samples );

    for( i = 0; i < samples; i++ )
    {
        ret = mbedtls_mpi_fill_random( &X, (size_t)mpi_size,
                                       timeconst_random, ctr_drbg );
        if( ret != 0 )
            goto exit;

        ret = timeconst_random( ctr_drbg, (unsigned char *)&shift_cnt,
                                       sizeof( size_t ) );
        if( ret != 0 )
            goto exit;
        shift_cnt = shift_cnt % ( mpi_size * 8 + 1 );

        start_time = mbedtls_timing_threadclock();
        ret = fut( &X, shift_cnt );
        end_time = mbedtls_timing_threadclock();
        if( ret != 0 )
            goto exit;

        ret = mbedtls_timeconst_add_sample( &timeconst,
                                            TIMECONST_TIMEDIFF( start_time, end_time, time_adj ) );
        if( ret != 0 )
            goto exit;
    }

    TIMECONST_STATS( &timeconst, fut_str );

exit:
    mbedtls_mpi_free( &X );
    mbedtls_timeconst_free( &timeconst );

    return( ret );
}
/* END_CASE */
